\chapter{結論}
\section{まとめ}
本研究では、マイクロコントローラにおいて実行されることを前提とした独自のFRP言語を考案し、そのコンパイラを実装した。
実例研究として、実際にこのコンパイラを用いて実用的な組み込みシステムを開発し、実行時性能の評価を行った。
最後に本言語の記述性と実用性についての議論を行い、既存の研究との関連についても述べた。

\section{今後の課題}

%\subsection{反復的な処理の記述をサポート}

\subsection{無名関数および第一級関数}
無名関数及び第一級関数をSFRP言語に導入することは可能である。
ただし現状の第一級でない関数と同様、再帰に関しては制限を受けることになる。
% また、クロージャは束縛される局所変数の個数に依存してデータサイズが決まるため、
% 代数的データ構造のように単純に型からデータサイズを特定することができず、
% \ref{sec:language:memory}節における評価を直接適用することはできない。
% 実装に際してはこの点について何らかの対処が必要になるだろう。

\subsection{任意の場所での初期値定義}
現状のSFRPではトップレベルに定義される時変値であるノードに対してのみ、初期値の定義及び直前値の参照が許されている。
これは\ref{sec:language:model}節における計算モデルには存在しない制約であり、
SFRPにとっても本質的に必要とされる制約ではない。
この制約が存在しなければ、時変値に対して初期値を付与する関数や時変値の直前値を参照する関数などを定義することが可能となり、
時変値に関する定形処理の記述が容易になる。
ただし動的メモリ確保を排除する現在の設計方針の元でこの制約を撤廃することは、
コンパイラ実装の観点から見れば容易ではないと予想される。

% \subsection{外部ノードの定義に変数を許す}
% 多くのマイクロコントローラにおいてメモリマップドI/Oによる入出力インターフェースが採用されていることから、
% 外部ノード定義の入力源に直接これを指定できるようになれば大変便利である。

\subsection{内部ポーリングの手動制御}
現状のSFRPでは、時変値更新のための内部ポーリングを自由に制御することはできない。
このため、システムをスリープモードへ移行させる処理などを記述することは難しいと思われる。
また、時変値更新のタイミングをユーザが独自に制御したいというケースもあるかもしれない。
内部ポーリングの手動制御を実施するインターフェースを言語内に導入すれば、そういったニーズに応えることができると思われる。
