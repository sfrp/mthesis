\chapter{記述性と実用性}
本章ではSFRPが持つ様々な特徴を取り上げ、それらが記述性と実用性に与える影響について論じる。

\section{代数的データ構造とパターンマッチ}
組込みシステムの状態は代数的データ構造を用いて簡潔に表現することができる。
組込みシステムの状態は複数の状態変数の積和で表現されることが多いが、
代数的データ構造とパターンマッチが導入されることにより、フラグ変数などをユーザが別途管理すること無く、
言語レベルで状態変数の積和が表現可能となる。

代数的データ構造とパターンマッチの組み合わせは状態変数へのアクセスを安全に行うことにも貢献する。
代数的データ構造が要素として持つ状態変数はパターンマッチによってのみ取り出すことが許されるため、
パターンにマッチした場合、すなわちその状態変数が有効である場合にのみ参照が発生する。
したがって無効な状態変数を誤って参照してしまうような事態は起こりえなくなる。

パターンマッチによる処理の分岐は、網羅性の判定を機械的かつ決定的に行うことができるのも大きな利点である。
例えばC言語のif文の場合、分岐の網羅性を機械的に保証するためには末尾にelse節を追加する必要がある。
しかし複数の分岐の後に接続されるelse節はどのような場合に到達するのかが一見して分かりづらく、プログラムの見通しを悪化させる。
その点、パターンマッチによる処理の分岐は末尾にelse節のようなものを追加せずとも、
実際に網羅的であるのならば機械的にそれを判定し、安全性を保証することができる。

\section{シームレスな時変値プログラミング}
全ての値を時変値として見なすことにより、従来通りであれば通常の値に対してのみ許されるような演算を、
時変値に対して直に行うことができる。
すなわちパターンマッチ式やif式、\texttt{+}や\texttt{-}などの各種演算子を、
時変値に対して直接適用することができる。
これによりユーザは意識的に時変値と通常の値を使い分ける必要がなくなり、直感的に処理を記述することができるようになる。

\section{再帰の禁止}
再帰的な関数の利用はメモリの動的確保を必要とするため、組込みシステム開発において用いることは望ましくない。
関数が呼び出される際にはスタック領域のメモリが消費されるが、
再帰的な関数呼び出しの場合、この消費メモリの上限を定めることが難しいため、プログラム全体のメモリ使用量の見積もりが困難となる。
また再帰的関数の内部で代数的データ構造の確保を行う場合、
\ref{sec:language:memory}節において打ち立てたメモリ使用量の評価が成り立たなくなってしまう。

SFRPでは再帰的な関数の定義を一切禁止しているが、
SFRPにはC言語におけるfor文のようなループ構文が存在しないため、
非リアクティブな反復処理
\footnote{非リアクティブな反復処理の例としては、最小公倍数を求める処理などが考えられる}
を直接的に表現する手段が無いことになる。
現状のSFRPでは、全ての反復処理は時変値の直前値参照を介して行われる必要があり、
非リアクティブな反復処理を記述する際にはやや不便であるといえる。
%こういった処理は外部定義インターフェースを利用してC言語にて記述してしまうという手もある。

ただし反復処理が制限されることによってプログラムのリアルタイム性が保証されるため、このことは一概に欠点であるとは言えない。
すなわち反復処理を自由に記述することが許されているということは、
無限ループやそれに近い重い処理を記述することを許してしまうということであり、
リアルタイム性を損ねる記述を可能にしてしまうということなのである。

再帰的な関数の利用と同様、再帰的なデータ構造の利用もまたメモリの動的確保を必要とするため、組込みシステム開発において用いることは望ましくない。
再帰的なデータ構造は、1つの値を保持するために必要なメモリ量の上限を定めることができず、
プログラムのメモリ使用量の見積もりを困難にしてしまうためである。
また再帰的な代数的データ構造の利用を許す場合、
\ref{sec:language:memory}節におけるメモリ使用量の評価は成り立たなくなってしまう。

記述するシステムの特性によっては、それでも再帰的なデータ構造が必要となるケースがあるかもしれない。
しかし現状のSFRPはそういった状況への直接的なサポートは行っていないため、
外部定義とI/O処理を介して間接的に実現することになる。

\section{破壊的な変更の禁止}
SFRPの言語内においてデータに対する破壊的な操作を行うことは許されていない。
これはSFRPが参照透明性を保証する純粋関数型言語であるための制約である。
現状のSFRPではポインタの読み書き等の処理を行いたい場合は外部定義とI/O処理を介して行う必要があり、
破壊的な変更を多く用いる必要のあるシステムを記述するにはやや不向きであると言える。

\section{外部ノード定義とノード出力定義}
外部に存在する時変値を言語内で取り扱うための構文として外部ノード定義がある。
入力値を取得するI/O関数の引数として他の時変値を渡すことができるので、アプリケーションの出力をフィードバックすることができる。

外部に存在する時変値の定義を言語内で与えるための構文としてノード出力定義がある。
出力値を外部に反映するI/O関数には複数の引数を与えることができるため、
出力に用いる時変値を単一のデータ構造に纏める必要はない。

マイクロコントローラ一般を対象とし、入出力の形式を特定できない以上、
このような構文を導入して入出力処理をユーザに委ねることは妥当であると言える。
記述性についても前述のような配慮がされており、特に問題はないだろう。

\section{通常関数とI/O関数}
SFRPは入出力処理の実行を計算モデル内に隠蔽しているため、純粋関数型言語であると言える。
しかし副作用を伴う処理の記述を完全に禁止してしまうと、入出力処理を全て外部定義によって記述しなければならなくなるため不便である。
そこでSFRPでは、通常関数とI/O関数を分けることにより、入出力処理を記述する場合にのみ限って副作用を伴った処理の記述を許している。
すなわち外部定義によって導入されたI/O関数に加え、他のI/O関数を呼び出すI/O関数を内部定義することができる。
これにより単純なI/O関数を組み合わせて複雑なI/O関数を定義することがSFRPの言語内において可能となり、
I/O関数を外部定義しなければならないケースが削減される。

\section{外部定義}
外部の言語を用いた定義をサポートする際に最も問題となるのが、2つの言語間におけるデータ型の対応である。
SFRPでは言語内で独自に定義される代数的データ構造を外部に晒すことはせず、\texttt{Int}型や
\texttt{Bool}型などC言語のプリミティブ型を用いて表現可能なデータ型のみを外部関数の型として認めている。
ただし、これだけでは外部関数が複数の値を返す手段がなくなってしまうため、\texttt{Tuple}型のみ特別に返り値型としてサポートされている。

間接的な方法ではあるが、\texttt{Tuple}型を用いて他の代数的データ型を表現することは可能である。
たとえば\texttt{Maybe[Int]}型は以下のように\texttt{(Bool, Int)}型によって表現することができる。
\begin{center}
  \texttt{(True, x)} $\rightarrow$ \texttt{Just(x)}\\ \texttt{(False, \_)} $\rightarrow$ \texttt{Nothing}
\end{center}
