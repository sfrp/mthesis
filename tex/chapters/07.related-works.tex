\chapter{関連研究}
\section{Elm}
Elm\cite{czaplicki2012elm,czaplicki2013asynchronous}はWebアプリケーションのフロントエンド開発のためのFRP言語である。
2012年に発表され、現在も活発に開発が続けられている。
現在のElmは伝統的なFRPに基づく抽象化の手法からは距離を置いているが、ここでは発表当初のオリジナルのElmについて述べる。

SFRPが採用するFRPの手法は、既存のFRP手法の中では、オリジナルのElmのものに比較的近い。
SFRPにおける初期値付き時変値は、Elmのfoldpによる状態付きSignalを一般化したものとみなすことができる。
Elmのfoldpは対象となる時変値の直前値をその時変値の定義に用いることを許すが、
SFRPの\texttt{init}による初期値定義と\texttt{@@}による直前値参照は、
対象となる時変値の直前値を任意の時変値の定義に用いることを許す。

オリジナルのElmは入力イベントの発生をトリガーとして時変値の差分更新を行うプッシュ型のイベント駆動FRPであるが、
SFRPは入力値の変化に依らず常に時変値の更新を続けるポーリング形式のFRPである。
HaskellにおけるFRPフレームワークであるYampa\cite{hudak2003arrows}等が同様にこのポーリング形式を採用している。
ポーリングによる値の更新モデルはその単純さ故に実装の容易さや汎用性の面で優位であるが、
常に更新処理を続ける分、実行時の計算量の面では不利となる。
しかしSFRPの場合はシングルスレッドの小規模アーキテクチャ上で実行されることを前提としているため、
イベント駆動方式を採用してCPUの空き時間を増やしたところであまり大きなメリットはない。
つまり、リアルタイム性が損なわれない限りにおいては、無理に計算量を削減する必要性はあまりない。
SFRPの場合、1回の更新処理に要する計算時間は小さくなるなるように設計されているため、
更新処理が連続的に行われていたとしてもリアルタイム性が下がるということはなく、従ってポーリング形式が即していると言える。

\section{RxCpp}
ReactiveXライブラリ\cite{rxwebsite}のC++における実装であるRxCpp\cite{rxcppwebsite}
は非常に強力なリアクティブプログラミングツールである。
RxCppはC++11以降の言語機能やSTLを大いに活用した実装であり、
Javaにおける実装であるRxJava等にも引けを取らない高レベルな機能を擁す。
その反面、省メモリ性などへの配慮はあまりされておらず、SFRPが対象とするような小規模組込みシステムの記述に適しているとは言い難い。
今後、省メモリ性を意識したネイティブ環境向けのReactiveX実装が生まれれば、
小規模組込みシステムにも活用できる可能性は大いにある。

\section{EsterelとC{\'eu}}
Esterel\cite{boussinot1991esterel}はリアルタイムシステム向けの命令的・同期的なプログラミング言語である。
命令の即時実行性が言語のセマンティクスに組み込まれており、ノンブロッキングな処理とそうでない処理が明示的に分けて扱われる。
ブロッキングな処理はプリエンプションのトリガーとなり、1ステップ分の処理を実行した後に他の処理対象へと実行権が移動する。
これにより複数の処理対象間における決定的な並行性が実現される。

C{\'e}u\cite{sant2015structured}はEsterelの影響を強く受けた組込みシステム向けのプログラミング言語である。
基本的なコンセプトはEsterelと同様であるが、独自の機構を導入することで記述性やGUIプログラミング等への適合性を高めている。

C{\'e}uおよびEsterelが採用する手法は、同期的な並行処理によって組込みシステムを記述するという点においてFRPと共通する。
ただしFRPはその参照透明性を利用することによって非同期的な実行を取り入れることも可能であり、
オリジナルのElmにおける\texttt{async}などはその例の1つである。

\section{LustreとSignal}
Lustre\cite{caspi1987lustre}およびSignal\cite{leguernic1991programming}は、リアルタイムシステム向けの宣言的・同期的なデータフロープログラミング言語である。
データ間の依存関係を定義することによってプログラムの動作が表現される。
FRPはデータフロープログラミングの手法を純粋関数型プログラミングの枠内で実現したものとみなすこともできる。

\section{Simulink}
Simulink\cite{simulinkwebsite}はブロック線図を元にして組み込みシステムの挙動をシミュレートするツールである。
ブロック線図から組み込みシステムを動作させるC言語コードを生成することもできる。
FRPはブロック線図をプログラムによって表現する手法とみなすこともできるため、
Simulinkの手法はFRPの手法に通じるものがある。
複雑な数値計算を取り扱うシステムには低レベルなリアルタイム性に優れたSimulinkによる記述がより適し、
複雑な状態遷移を取り扱うシステムにはソフトウェア的な表現性に優れたFRPによる記述がより適していると言える。

\section{CFRPとJuniper}
CFRP\cite{suzuki2016cfrp}は小規模組み込みシステム向けのFRP言語であり、オリジナルのElmのサブセットとなっている。
Juniper\cite{helbling2016juniper}はArduino向けのFRP言語であり、オリジナルのElmに近いFRPの手法を採用する非純粋関数型言語となっている。
いずれもSFRPと同様、メモリ資源が乏しい環境でFRPを行う試みとなっている。

\section{Emfrp}
Emfrp\cite{sawada2016emfrp}は筆者によるもう1つの小規模組込みシステム向けFRP言語であり、SFRPの前身となる存在である。
SFRPはEmfrpにおける入出力の手法と全体の構文をより洗練させた言語である。
ただし、Emfrpにおいて導入されている全ての機能がSFRPにおいても導入されているわけではないため、
現在のところSFRPがEmfrpの上位存在であるとは一概に言えない。
例えばEmfrpにはユニットテストに関するサポートやノード生成の雛形となる\texttt{module}構文が導入されているが、
これらに相当する機能はSFRPには存在しない。
SFRPとEmfrpは現在のところ互いに独立した存在であるが、
両者の目的は一致しているため将来的には統合される可能性がある。
